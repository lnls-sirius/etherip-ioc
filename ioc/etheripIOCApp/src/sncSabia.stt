program sncSabia

%%//----------------------------------------
%%//    Global Variables
%%//----------------------------------------

#define DELTA_PERIOD 52.5
#define ARR_SIVE_CONV_SHIFT_K 1001
#define ARR_SIVE_CONV_K_ENERGY 1001
#define LOG_MON_SIZE 120

double arr_x_conv_shift_k[ARR_SIVE_CONV_SHIFT_K];
double arr_y_lv_conv_shift_k[ARR_SIVE_CONV_SHIFT_K];
double arr_y_lh_conv_shift_k[ARR_SIVE_CONV_SHIFT_K];
double arr_y_cr_conv_shift_k[ARR_SIVE_CONV_SHIFT_K];
double arr_y_cl_conv_shift_k[ARR_SIVE_CONV_SHIFT_K];

double arr_x_conv_k_energy[ARR_SIVE_CONV_K_ENERGY];
double arr_y_conv_k_energy[ARR_SIVE_CONV_K_ENERGY];

typedef enum polarization {
    polCircRight = 0,
    polCircLeft = 1,
    polLinVert = 2,
    polLinHor = 3
} polarization;

%%//----------------------------------------
%%//    Monitored PVs - High Level
%%//----------------------------------------

int pos_tolerance_sp;
assign pos_tolerance_sp to "{P}{R}PosTolerance-SP";
monitor pos_tolerance_sp;

int change_pol_evt;
assign change_pol_evt to "{P}{R}ChangePolFlg";
monitor change_pol_evt;
evflag change_pol_evt_flg;
sync change_pol_evt change_pol_evt_flg;

int pol_type_sel;
assign pol_type_sel to "{P}{R}PolType-Sel";
monitor pol_type_sel;
evflag pol_type_sel_flg;
sync pol_type_sel pol_type_sel_flg;

int change_gain_evt;
assign change_gain_evt to "{P}{R}ChangeGainFlg";
monitor change_gain_evt;
evflag change_gain_evt_flg;
sync change_gain_evt change_gain_evt_flg;

int energy_sp;
assign energy_sp to "{P}{R}Energy-SP";
monitor energy_sp;
evflag energy_sp_flg;
sync energy_sp energy_sp_flg;

int k_sp;
assign k_sp to "{P}{R}K-SP";
monitor k_sp;
evflag k_sp_flg;
sync k_sp k_sp_flg;

int shift_sp;
assign shift_sp to "{P}{R}Shift-SP";
monitor shift_sp;
evflag shift_sp_flg;
sync shift_sp shift_sp_flg;

int start_escan_evt;
assign start_escan_evt to "{P}{R}StartEScanFlg";
monitor start_escan_evt;
evflag start_escan_evt_flg;
sync start_escan_evt start_escan_evt_flg;

int escan_start_pos_sp;
assign escan_start_pos_sp to "{P}{R}EScanStartPos-SP";
monitor escan_start_pos_sp;
evflag escan_start_pos_sp_flg;
sync escan_start_pos_sp escan_start_pos_sp_flg;

int escan_end_pos_sp;
assign escan_end_pos_sp to "{P}{R}EScanEndPos-SP";
monitor escan_end_pos_sp;
evflag escan_end_pos_sp_flg;
sync escan_end_pos_sp escan_end_pos_sp_flg;

int pol_mode_velo_sp;
assign pol_mode_velo_sp to "{P}{R}PolModeVelo-SP";
monitor pol_mode_velo_sp;
evflag pol_mode_velo_sp_flg;
sync pol_mode_velo_sp pol_mode_velo_sp_flg;

int pol_mode_acc_sp;
assign pol_mode_acc_sp to "{P}{R}PolModeAcc-SP";
monitor pol_mode_acc_sp;
evflag pol_mode_acc_sp_flg;
sync pol_mode_acc_sp pol_mode_acc_sp_flg;

int gain_mode_velo_sp;
assign gain_mode_velo_sp to "{P}{R}GainModeVelo-SP";
monitor gain_mode_velo_sp;
evflag gain_mode_velo_sp_flg;
sync gain_mode_velo_sp gain_mode_velo_sp_flg;

int gain_mode_acc_sp;
assign gain_mode_acc_sp to "{P}{R}GainModeAcc-SP";
monitor gain_mode_acc_sp;
evflag gain_mode_acc_sp_flg;
sync gain_mode_acc_sp gain_mode_acc_sp_flg;

int max_velo_sp;
assign max_velo_sp to "{P}{R}MaxVelo-SP";
monitor max_velo_sp;
evflag max_velo_sp_flg;
sync max_velo_sp max_velo_sp_flg;

int max_acc_sp;
assign max_acc_sp to "{P}{R}MaxAcc-SP";
monitor max_acc_sp;
evflag max_acc_sp_flg;
sync max_acc_sp max_acc_sp_flg;

int parking_request_evt;
assign parking_request_evt to "{P}{R}ParkingRequestFlg";
monitor parking_request_evt;
evflag parking_request_evt_flg;
sync parking_request_evt parking_request_evt_flg;

int pol_shift_mon;
assign pol_shift_mon to "{P}{R}PolShift-Mon";
monitor pol_shift_mon;

int pol_mon;
assign pol_mon to "{P}{R}Pol-Mon";
monitor pol_mon;

int gain_shift_mon;
assign gain_shift_mon to "{P}{R}GainShift-Mon";
monitor gain_shift_mon;

int k_mon;
assign k_mon to "{P}{R}K-Mon";
monitor k_mon;

int energy_mon;
assign energy_mon to "{P}{R}Energy-Mon";
monitor energy_mon;

%%// Conversion Coeff - Linear Vert Pol Shift to K

int lv_shift_to_k_evt;
assign lv_shift_to_k_evt to "{P}{R}LVShiftToKFlg";
monitor lv_shift_to_k_evt;
evflag lv_shift_to_k_evt_flg;
sync lv_shift_to_k_evt lv_shift_to_k_evt_flg;

int lv_shift_to_k_a0_sp;
assign lv_shift_to_k_a0_sp to "{P}{R}LVShiftToKA0-SP";
monitor lv_shift_to_k_a0_sp;

int lv_shift_to_k_a1_sp;
assign lv_shift_to_k_a1_sp to "{P}{R}LVShiftToKA1-SP";
monitor lv_shift_to_k_a1_sp;

int lv_shift_to_k_a2_sp;
assign lv_shift_to_k_a2_sp to "{P}{R}LVShiftToKA2-SP";
monitor lv_shift_to_k_a2_sp;

int lv_shift_to_k_a3_sp;
assign lv_shift_to_k_a3_sp to "{P}{R}LVShiftToKA3-SP";
monitor lv_shift_to_k_a3_sp;

int lv_shift_to_k_a4_sp;
assign lv_shift_to_k_a4_sp to "{P}{R}LVShiftToKA4-SP";
monitor lv_shift_to_k_a4_sp;

int lv_shift_to_k_a5_sp;
assign lv_shift_to_k_a5_sp to "{P}{R}LVShiftToKA5-SP";
monitor lv_shift_to_k_a5_sp;

int lv_shift_to_k_a6_sp;
assign lv_shift_to_k_a6_sp to "{P}{R}LVShiftToKA6-SP";
monitor lv_shift_to_k_a6_sp;

int lv_shift_to_k_a7_sp;
assign lv_shift_to_k_a7_sp to "{P}{R}LVShiftToKA7-SP";
monitor lv_shift_to_k_a7_sp;

int lv_shift_to_k_a8_sp;
assign lv_shift_to_k_a8_sp to "{P}{R}LVShiftToKA8-SP";
monitor lv_shift_to_k_a8_sp;

%%// Conversion Coeff - Linear Hor Pol Shift to K

int lh_shift_to_k_evt;
assign lh_shift_to_k_evt to "{P}{R}LHShiftToKFlg";
monitor lh_shift_to_k_evt;
evflag lh_shift_to_k_evt_flg;
sync lh_shift_to_k_evt lh_shift_to_k_evt_flg;

int lh_shift_to_k_a0_sp;
assign lh_shift_to_k_a0_sp to "{P}{R}LHShiftToKA0-SP";
monitor lh_shift_to_k_a0_sp;

int lh_shift_to_k_a1_sp;
assign lh_shift_to_k_a1_sp to "{P}{R}LHShiftToKA1-SP";
monitor lh_shift_to_k_a1_sp;

int lh_shift_to_k_a2_sp;
assign lh_shift_to_k_a2_sp to "{P}{R}LHShiftToKA2-SP";
monitor lh_shift_to_k_a2_sp;

int lh_shift_to_k_a3_sp;
assign lh_shift_to_k_a3_sp to "{P}{R}LHShiftToKA3-SP";
monitor lh_shift_to_k_a3_sp;

int lh_shift_to_k_a4_sp;
assign lh_shift_to_k_a4_sp to "{P}{R}LHShiftToKA4-SP";
monitor lh_shift_to_k_a4_sp;

int lh_shift_to_k_a5_sp;
assign lh_shift_to_k_a5_sp to "{P}{R}LHShiftToKA5-SP";
monitor lh_shift_to_k_a5_sp;

int lh_shift_to_k_a6_sp;
assign lh_shift_to_k_a6_sp to "{P}{R}LHShiftToKA6-SP";
monitor lh_shift_to_k_a6_sp;

int lh_shift_to_k_a7_sp;
assign lh_shift_to_k_a7_sp to "{P}{R}LHShiftToKA7-SP";
monitor lh_shift_to_k_a7_sp;

int lh_shift_to_k_a8_sp;
assign lh_shift_to_k_a8_sp to "{P}{R}LHShiftToKA8-SP";
monitor lh_shift_to_k_a8_sp;

%%// Conversion Coeff - Circ Right Pol Shift to K

int cr_shift_to_k_evt;
assign cr_shift_to_k_evt to "{P}{R}CRShiftToKFlg";
monitor cr_shift_to_k_evt;
evflag cr_shift_to_k_evt_flg;
sync cr_shift_to_k_evt cr_shift_to_k_evt_flg;

int cr_shift_to_k_a0_sp;
assign cr_shift_to_k_a0_sp to "{P}{R}CRShiftToKA0-SP";
monitor cr_shift_to_k_a0_sp;

int cr_shift_to_k_a1_sp;
assign cr_shift_to_k_a1_sp to "{P}{R}CRShiftToKA1-SP";
monitor cr_shift_to_k_a1_sp;

int cr_shift_to_k_a2_sp;
assign cr_shift_to_k_a2_sp to "{P}{R}CRShiftToKA2-SP";
monitor cr_shift_to_k_a2_sp;

int cr_shift_to_k_a3_sp;
assign cr_shift_to_k_a3_sp to "{P}{R}CRShiftToKA3-SP";
monitor cr_shift_to_k_a3_sp;

int cr_shift_to_k_a4_sp;
assign cr_shift_to_k_a4_sp to "{P}{R}CRShiftToKA4-SP";
monitor cr_shift_to_k_a4_sp;

int cr_shift_to_k_a5_sp;
assign cr_shift_to_k_a5_sp to "{P}{R}CRShiftToKA5-SP";
monitor cr_shift_to_k_a5_sp;

int cr_shift_to_k_a6_sp;
assign cr_shift_to_k_a6_sp to "{P}{R}CRShiftToKA6-SP";
monitor cr_shift_to_k_a6_sp;

int cr_shift_to_k_a7_sp;
assign cr_shift_to_k_a7_sp to "{P}{R}CRShiftToKA7-SP";
monitor cr_shift_to_k_a7_sp;

int cr_shift_to_k_a8_sp;
assign cr_shift_to_k_a8_sp to "{P}{R}CRShiftToKA8-SP";
monitor cr_shift_to_k_a8_sp;

%%// Conversion Coeff - Circ Left Pol Shift to K

int cl_shift_to_k_evt;
assign cl_shift_to_k_evt to "{P}{R}CLShiftToKFlg";
monitor cl_shift_to_k_evt;
evflag cl_shift_to_k_evt_flg;
sync cl_shift_to_k_evt cl_shift_to_k_evt_flg;

int cl_shift_to_k_a0_sp;
assign cl_shift_to_k_a0_sp to "{P}{R}CLShiftToKA0-SP";
monitor cl_shift_to_k_a0_sp;

int cl_shift_to_k_a1_sp;
assign cl_shift_to_k_a1_sp to "{P}{R}CLShiftToKA1-SP";
monitor cl_shift_to_k_a1_sp;

int cl_shift_to_k_a2_sp;
assign cl_shift_to_k_a2_sp to "{P}{R}CLShiftToKA2-SP";
monitor cl_shift_to_k_a2_sp;

int cl_shift_to_k_a3_sp;
assign cl_shift_to_k_a3_sp to "{P}{R}CLShiftToKA3-SP";
monitor cl_shift_to_k_a3_sp;

int cl_shift_to_k_a4_sp;
assign cl_shift_to_k_a4_sp to "{P}{R}CLShiftToKA4-SP";
monitor cl_shift_to_k_a4_sp;

int cl_shift_to_k_a5_sp;
assign cl_shift_to_k_a5_sp to "{P}{R}CLShiftToKA5-SP";
monitor cl_shift_to_k_a5_sp;

int cl_shift_to_k_a6_sp;
assign cl_shift_to_k_a6_sp to "{P}{R}CLShiftToKA6-SP";
monitor cl_shift_to_k_a6_sp;

int cl_shift_to_k_a7_sp;
assign cl_shift_to_k_a7_sp to "{P}{R}CLShiftToKA7-SP";
monitor cl_shift_to_k_a7_sp;

int cl_shift_to_k_a8_sp;
assign cl_shift_to_k_a8_sp to "{P}{R}CLShiftToKA8-SP";
monitor cl_shift_to_k_a8_sp;

%%// Conversion Coefficients - K to Energy

int k_to_energy_evt;
assign k_to_energy_evt to "KToEnergyFlg";
monitor k_to_energy_evt;
evflag k_to_energy_evt_flg;
sync k_to_energy_evt k_to_energy_evt_flg;

int k_to_energy_a0_sp;
assign k_to_energy_a0_sp to "{P}{R}KToEnergyA0-SP";
monitor k_to_energy_a0_sp;

int k_to_energy_a1_sp;
assign k_to_energy_a1_sp to "{P}{R}KToEnergyA1-SP";
monitor k_to_energy_a1_sp;

int k_to_energy_a2_sp;
assign k_to_energy_a2_sp to "{P}{R}KToEnergyA2-SP";
monitor k_to_energy_a2_sp;

int k_to_energy_a3_sp;
assign k_to_energy_a3_sp to "{P}{R}KToEnergyA3-SP";
monitor k_to_energy_a3_sp;

int k_to_energy_a4_sp;
assign k_to_energy_a4_sp to "{P}{R}KToEnergyA4-SP";
monitor k_to_energy_a4_sp;

int k_to_energy_a5_sp;
assign k_to_energy_a5_sp to "{P}{R}KToEnergyA5-SP";
monitor k_to_energy_a5_sp;

int k_to_energy_a6_sp;
assign k_to_energy_a6_sp to "{P}{R}KToEnergyA6-SP";
monitor k_to_energy_a6_sp;

int k_to_energy_a7_sp;
assign k_to_energy_a7_sp to "{P}{R}KToEnergyA7-SP";
monitor k_to_energy_a7_sp;

int k_to_energy_a8_sp;
assign k_to_energy_a8_sp to "{P}{R}KToEnergyA8-SP";
monitor k_to_energy_a8_sp;

%%//----------------------------------------
%%//    Output PVs - High Level
%%//----------------------------------------

char[LOG_MON_SIZE] log_mon;
assign log_mon to "{P}{R}Log-Mon";

int enbl_low_lvl_ctrl_proc;
assign enbl_low_lvl_ctrl_proc to "{P}{R}EnblLowLvlCtrl.PROC";

int dsbl_low_lvl_ctrl_proc;
assign dsbl_low_lvl_ctrl_proc to "{P}{R}DsblLowLvlCtrl.PROC";

%%//----------------------------------------
%%//    Monitored PVs - Low Level
%%//----------------------------------------

int state_idx_mon;
assign state_idx_mon to "{P}{R}StateIdx-Mon";
monitor state_idx_mon;

int motion_state_mon;
assign motion_state_mon to "{P}{R}MotionState-Mon";
monitor motion_state_mon;

%%//----------------------------------------
%%//    Output PVs - Low Level
%%//----------------------------------------

int rst_cmd;
assign rst_cmd to "{P}{R}Rst-Cmd";

int rel_pos_sp;
assign rel_pos_sp to "{P}{R}RelPos-SP";

int velo_sp;
assign velo_sp to "{P}{R}Velo-SP";

int acc_sp;
assign acc_sp to "{P}{R}Acc-SP";

int decel_sp;
assign decel_sp to "{P}{R}Decel-SP";

int phy_cid_actual_pos_mon;
assign phy_cid_actual_pos_mon to "{P}{R}PhyCIDActualPos-Mon";

int phy_cie_actual_pos_mon;
assign phy_cie_actual_pos_mon to "{P}{R}PhyCIEActualPos-Mon";

int phy_csd_actual_pos_mon;
assign phy_csd_actual_pos_mon to "{P}{R}PhyCSDActualPos-Mon";

int phy_cse_actual_pos_mon;
assign phy_cse_actual_pos_mon to "{P}{R}PhyCSEActualPos-Mon";

int coup_sel;
assign coup_sel to "{P}{R}Coup-Sel";

int trig_type_sel;
assign trig_type_sel to "{P}{R}TrigType-Sel";

int ref_type_sel;
assign ref_type_sel to "{P}{R}RefType-Sel";

int inter_mod_coup_sel;
assign inter_mod_coup_sel to "{P}{R}InterModCoup-Sel";

int mirror_sel;
assign mirror_sel to "{P}{R}Mirror-Sel";

int soft_trig_cmd;
assign soft_trig_cmd to "{P}{R}SoftTrig-Cmd";

%%//----------------------------------------
%%//        Escaped C Code
%%//----------------------------------------

// required for calling seq_pvPut, seq_pvGet from embedded C code
foreign ssId;

%%#include <unistd.h>
%%#include <stdio.h>
%%#include <string.h>
%%#include <math.h>
%%#include "Logger.h"
%%#include "myUtil.h"

// parking position
%%#define PARKING_POL_SHIFT 0.0
%%#define PARKING_GAIN_SHIFT -26.25

// coupling modes
%%#define COUPLING_UNCOUPLED 0
%%#define COUPLING_ALL 1
%%#define COUPLING_PHASE 2
%%#define COUPLING_COUNTERPHASE 3
%%#define COUPLING_GV 4
%%#define COUPLING_GH 5

// main polarization positions (mm)
%%#define POL_LIN_VERT -26.25
%%#define POL_CIRC_RIGHT -13.125
%%#define POL_LIN_HOR 0.0
%%#define POL_CIRC_LEFT 13.125
%%// #define POL_LIN_VERT 26.25

//main energy positions (mm)
%%#define GAIN_ZERO_K 0.0

// trigger
%%#define TRIG_TYPE_BOTH 0
%%#define TRIG_TYPE_SOFT 1
%%#define TRIG_TYPE_HARD 2

// inter-module coupling
%%#define INTER_MOD_COUPLING_001 1

// motion reference type
%%#define REFERENCE_TYPE_INTERNAL 0
%%#define REFERENCE_TYPE_EXTERNAL 1

// coupling mirror config
%%#define MIRROR_DISABLE 0
%%#define MIRROR_ENABLE 1

// motion state
%%#define MOTION_STATE_MOVING 0
%%#define MOTION_STATE_DONE 1

// clp state machine
%%#define STATE_MACHINE_UNDEFINED 0
%%#define STATE_MACHINE_CLEARING 1
%%#define STATE_MACHINE_STOPPED 2
%%#define STATE_MACHINE_STARTING 3
%%#define STATE_MACHINE_IDLE 4
%%#define STATE_MACHINE_SUSPENDED 5
%%#define STATE_MACHINE_EXECUTE 6
%%#define STATE_MACHINE_STOPPING 7
%%#define STATE_MACHINE_ABORTING 8
%%#define STATE_MACHINE_ABORTED 9
%%#define STATE_MACHINE_HOLDING 10
%%#define STATE_MACHINE_HELD 11
%%#define STATE_MACHINE_UNHOLDING 12
%%#define STATE_MACHINE_SUSPENDING 13
%%#define STATE_MACHINE_UNSUSPENDING 14
%%#define STATE_MACHINE_RESETTING 15
%%#define STATE_MACHINE_COMPLETING 16
%%#define STATE_MACHINE_COMPLETE 17

%{

/*
  Name: mm2k

  Description:

  Converts cassette shift in mm to the corresponding
  value of K, i.e., undulator strength parameter.

  shift [mm] -> K

  Arguments:

  pol: polarization type.
  shift: cassette shift in mm.
  p_k: pointer to undulator current k value.

  Return value:

  0: success
 -1: error: input value out of table bounds.
 -2: error: binary search failed.
 -3: error: division by zero when calculating slope.

*/
char mm2k(polarization pol, double shift, double* p_k){

    char * k_values;

    // select conversion array
    if (pol == polLinVert) {k_values = arr_y_lv_conv_shift_k;}
    else if (pol == polLinHor) {k_values = arr_y_lh_conv_shift_k;}
    else if (pol == polCircRight) {k_values = arr_y_cr_conv_shift_k;}
    else if (pol == polCircLeft) {k_values = arr_y_cl_conv_shift_k;}

    // perform conversion through linear interpolation
    return interpolateFromTable(arr_x_conv_shift_k,
                                k_values,
                                ARR_SIVE_CONV_SHIFT_K,
                                p_k,
                                shift);
}

/*
  Name: k2mm

  Description:

  Converts undulator K value, i.e., the undulator strength parameter,
  to the corresponding cassette shift, in mm.

  K -> shift [mm]

  Arguments:

  pol: polarization type.
  k: undulator current k value.
  p_shift: pointer to cassette shift value in mm.

  Return value:

  0: success
 -1: error: input value out of table bounds.
 -2: error: binary search failed.
 -3: error: division by zero when calculating slope.

*/
char k2mm(polarization pol, double k, double* p_shift){

    char * k_values;

    // select conversion array
    if (pol == polLinVert) {k_values = arr_y_lv_conv_shift_k;}
    else if (pol == polLinHor) {k_values = arr_y_lh_conv_shift_k;}
    else if (pol == polCircRight) {k_values = arr_y_cr_conv_shift_k;}
    else if (pol == polCircLeft) {k_values = arr_y_cl_conv_shift_k;}

    // perform conversion through linear interpolation
    return interpolateFromTable(k_values,
                                arr_x_conv_shift_k,
                                ARR_SIVE_CONV_SHIFT_K,
                                p_shift,
                                k);
}

char k2energy(polarization pol, double k, double* p_energy){

    // perform conversion through linear interpolation
    return interpolateFromTable(arr_x_conv_k_energy,
                                arr_y_conv_k_energy,
                                ARR_SIVE_CONV_K_ENERGY,
                                p_energy,
                                k);
}

char energy2k(polarization pol, double energy, double* p_k){

    // perform conversion through linear interpolation
    return interpolateFromTable(arr_y_conv_k_energy,
                                arr_x_conv_k_energy,
                                ARR_SIVE_CONV_K_ENERGY,
                                p_k,
                                energy);
}

}%

%%//----------------------------------------
%%//        State Notation Language
%%//----------------------------------------

ss motion_control {
    state init {
	when (delay(5.0)) {

            LOG_INFO("[%s%s] Initialization start\n", macValueGet("P"), macValueGet("R"));

            /* Initialize arrays */

            double step, max_travel, start;

            // initialize Shift - K conversion table x values

            max_travel = DELTA_PERIOD / 2;

            start = 0.0;

            step = max_travel/ (ARR_SIVE_CONV_SHIFT_K - 1);

            for (int i=0; i < ARR_SIVE_CONV_SHIFT_K; i++) {
                arr_x_conv_shift_k[i] = start + i * step;
            }

            // initialize K - Energy conversion table x values

            max_travel = DELTA_PERIOD;

            start = -1 * DELTA_PERIOD/2;

            step = max_travel/ (ARR_SIVE_CONV_K_ENERGY - 1);

            for (int i=0; i < ARR_SIVE_CONV_K_ENERGY; i++) {
                arr_x_conv_k_energy[i] = start + i * step;
            }

            LOG_INFO("[%s%s] Initialization finished\n", macValueGet("P"), macValueGet("R"));
	} state waiting
    }

    state waiting {

        when (state_idx_mon == STATE_MACHINE_IDLE) {
        } state ready

        when (state_idx_mon == STATE_MACHINE_STOPPED
              || state_idx_mon == STATE_MACHINE_COMPLETE) {
            
            /* send reset command to
               PLC state machine */
            rst_cmd = 1;
            pvPut(rst_cmd, SYNC);

        } state waiting

	when (efTest(parking_request_evt)
              || efTest(change_pol_evt)
              || efTest(change_gain_evt)
              || efTest(start_escan_evt)) {

            // clear flags
            efClear(parking_request_evt);
            efClear(change_pol_evt);
            efClear(change_gain_evt);
            efClear(start_escan_evt);

            // print warning log message
            strlcpy(log_mon,
                    "Cannot start new move: PLC program state not IDLE",
                    sizeof(log_mon));
            pvPut(log_mon, SYNC);

        } state waiting

    }

    state ready {
        entry {
            /* clear event flags to avoid
               running old invalid commands */
            efClear(change_pol_evt);
            efClear(change_gain_evt);
	    efClear(start_escan_evt);
            efClear(parking_request_evt);
        }

        when (state_idx_mon != STATE_MACHINE_IDLE) {
        } state waiting

        when (efTestAndClear(lv_shift_to_k_evt)) {
        } state update_lv_shift_to_k_conv

        when (efTestAndClear(lh_shift_to_k_evt)) {
        } state update_lh_shift_to_k_conv

        when (efTestAndClear(cr_shift_to_k_evt)) {
        } state update_cr_shift_to_k_conv

        when (efTestAndClear(cl_shift_to_k_evt)) {
        } state update_cl_shift_to_k_conv

        when (efTestAndClear(k_to_energy_evt)) {
        } state update_k_to_energy_conv

	when (efTestAndClear(parking_request_evt)) {
        } state start_parking

	when (efTestAndClear(change_pol_evt)) {
        } state change_pol

	when (efTestAndClear(change_gain_evt)) {
        } state change_gain

	when (efTestAndClear(start_escan_evt)) {
        } state start_escan

    }

    state update_lv_shift_to_k_conv {

        entry {

            /* Update LV Shift to K convertion table */

            for (int i=0; i < ARR_SIVE_CONV_SHIFT_K; i++) {
                double x = arr_x_conv_shift_k[i];

                // calculate corresponding y value
                arr_y_lv_conv_shift_k[i] = lv_shift_to_k_a8_sp * pow(x, 8)
                                         + lv_shift_to_k_a7_sp * pow(x, 7)
                                         + lv_shift_to_k_a6_sp * pow(x, 6)
                                         + lv_shift_to_k_a5_sp * pow(x, 5)
                                         + lv_shift_to_k_a4_sp * pow(x, 4)
                                         + lv_shift_to_k_a3_sp * pow(x, 3)
                                         + lv_shift_to_k_a2_sp * pow(x, 2)
                                         + lv_shift_to_k_a1_sp * pow(x, 1)
                                         + lv_shift_to_k_a0_sp;
            }
        }

        when () {
        } state ready
    }

    state update_lh_shift_to_k_conv {

        entry {

            /* Update LH Shift to K convertion table */

            for (int i=0; i < ARR_SIVE_CONV_SHIFT_K; i++) {
                double x = arr_x_conv_shift_k[i];

                // calculate corresponding y value
                arr_y_lh_conv_shift_k[i] = lh_shift_to_k_a8_sp * pow(x, 8)
                                         + lh_shift_to_k_a7_sp * pow(x, 7)
                                         + lh_shift_to_k_a6_sp * pow(x, 6)
                                         + lh_shift_to_k_a5_sp * pow(x, 5)
                                         + lh_shift_to_k_a4_sp * pow(x, 4)
                                         + lh_shift_to_k_a3_sp * pow(x, 3)
                                         + lh_shift_to_k_a2_sp * pow(x, 2)
                                         + lh_shift_to_k_a1_sp * pow(x, 1)
                                         + lh_shift_to_k_a0_sp;
            }
        }

        when () {
        } state ready
    }

    state update_cr_shift_to_k_conv {

        entry {

            /* Update CR Shift to K convertion table */

            for (int i=0; i < ARR_SIVE_CONV_SHIFT_K; i++) {
                double x = arr_x_conv_shift_k[i];

                // calculate corresponding y value
                arr_y_cr_conv_shift_k[i] = cr_shift_to_k_a8_sp * pow(x, 8)
                                         + cr_shift_to_k_a7_sp * pow(x, 7)
                                         + cr_shift_to_k_a6_sp * pow(x, 6)
                                         + cr_shift_to_k_a5_sp * pow(x, 5)
                                         + cr_shift_to_k_a4_sp * pow(x, 4)
                                         + cr_shift_to_k_a3_sp * pow(x, 3)
                                         + cr_shift_to_k_a2_sp * pow(x, 2)
                                         + cr_shift_to_k_a1_sp * pow(x, 1)
                                         + cr_shift_to_k_a0_sp;
            }
        }

        when () {
        } state ready
    }

    state update_cl_shift_to_k_conv {

        entry {

            /* Update CL Shift to K convertion table */

            for (int i=0; i < ARR_SIVE_CONV_SHIFT_K; i++) {
                double x = arr_x_conv_shift_k[i];

                // calculate corresponding y value
                arr_y_cl_conv_shift_k[i] = cl_shift_to_k_a8_sp * pow(x, 8)
                                         + cl_shift_to_k_a7_sp * pow(x, 7)
                                         + cl_shift_to_k_a6_sp * pow(x, 6)
                                         + cl_shift_to_k_a5_sp * pow(x, 5)
                                         + cl_shift_to_k_a4_sp * pow(x, 4)
                                         + cl_shift_to_k_a3_sp * pow(x, 3)
                                         + cl_shift_to_k_a2_sp * pow(x, 2)
                                         + cl_shift_to_k_a1_sp * pow(x, 1)
                                         + cl_shift_to_k_a0_sp;
            }
        }

        when () {
        } state ready
    }

    state update_k_to_energy_conv {

        entry {

            /* Update K to Energy convertion table */

            for (int i=0; i < ARR_SIVE_CONV_K_ENERGY; i++) {
                double x = arr_conv_k_energy[0][i];

                // calculate corresponding y value
                arr_conv_k_energy[1][i] = k_to_energy_a8_sp * pow(x, 8)
                                          + k_to_energy_a7_sp * pow(x, 7)
                                          + k_to_energy_a6_sp * pow(x, 6)
                                          + k_to_energy_a5_sp * pow(x, 5)
                                          + k_to_energy_a4_sp * pow(x, 4)
                                          + k_to_energy_a3_sp * pow(x, 3)
                                          + k_to_energy_a2_sp * pow(x, 2)
                                          + k_to_energy_a1_sp * pow(x, 1)
                                          + k_to_energy_a0_sp;
            }
        }

        when () {
        } state ready
    }

    state change_pol {

        entry {

            // local variables
            double var_target_pol, var_pos_diff;
            char var_check;

            // find target polarization
            if (pol_type_sel == 0) {
                var_target_pol = POL_CIRC_RIGHT;
            }
            else if (pol_type_sel == 1) {
                var_target_pol = POL_CIRC_LEFT;
            }
            else if (pol_type_sel == 2) {
                var_target_pol = POL_LIN_VERT;
            }
            else if (pol_type_sel == 3) {
                var_target_pol = POL_LIN_HOR;
            }

            // calculate position diff
            var_pos_diff = var_target_pol - pol_shift_mon;

            // check if diff is inside tolerance
            var_check = 1;
            if (var_pos_diff > pos_tolerance_sp
                || var_pos_diff < -pos_tolerance_sp) {

                var_check = 0;
            }

            // move to position
            if (check == 1) {
                // configure trigger to software
                trig_type_sel = TRIG_TYPE_SOFT;
                pvPut(trig_type_sel, SYNC);

                // make sure inter module coupling is right
                inter_mod_coup_sel = INTER_MOD_COUPLING_001;
                pvPut(inter_mod_coup_sel, SYNC);

                // configure motion reference type
                ref_type_sel = REFERENCE_TYPE_INTERNAL;
                pvPut(ref_type_sel, SYNC);

                // select phase coupling
                coup_sel = COUPLING_PHASE;
                pvPut(coup_sel, SYNC);

                // make sure mirror is disabled
                mirror_sel = MIRROR_DISABLE;
                pvPut(mirror_sel, SYNC);

                // configure velocity
                velo_sp = pol_mode_velo_sp;
                pvPut(velo_sp, SYNC);
                // configure acceleration
                acc_sp = pol_mode_acc_sp;
                pvPut(acc_sp, SYNC);
                // configure deceleration equal acceleration
                decel_sp = pol_mode_acc_sp;
                pvPut(decel_sp, SYNC);

                // configure relative position
                rel_pos_sp = var_pos_diff;
                pvPut(rel_pos_sp, SYNC);

                // send soft trigger to start motion
                soft_trig_cmd = 1;
                pvPut(soft_trig_cmd, SYNC);
            }
        }

        when (delay(1.0) && motion_state_mon == MOTION_STATE_DONE) {
        } state waiting
    }

    state change_gain {

        entry {

            // local variables
            double var_target_k, var_target_energy, var_pos_diff, var_target_mm = 0;
            char var_check, var_dir = 1;

            // target position same as shift
            var_target_mm = shift_sp;

            // find direction of gain motion given current polarization
            if (var_target_pol >=0) {
                var_dir = -1;
            }
            else {
                var_dir = 1;
            }

            var_target_mm = var_dir * var_target_mm;

            // calculate position diff
            var_pos_diff = var_target_mm - gain_shift_mon;

            // check if diff is inside tolerance
            var_check = 1;
            if (var_pos_diff > pos_tolerance_sp
                || var_pos_diff < -pos_tolerance_sp) {

                var_check = 0;
            }

            // move to position
            if (check == 1) {
                // configure trigger to software
                trig_type_sel = TRIG_TYPE_SOFT;
                pvPut(trig_type_sel, SYNC);

                // make sure inter module coupling is right
                inter_mod_coup_sel = INTER_MOD_COUPLING_001;
                pvPut(inter_mod_coup_sel, SYNC);

                // configure motion reference type
                ref_type_sel = REFERENCE_TYPE_INTERNAL;
                pvPut(ref_type_sel, SYNC);

                // select gain coupling (GH)
                coup_sel = COUPLING_GH;
                pvPut(coup_sel, SYNC);

                // make sure mirror is disabled
                mirror_sel = MIRROR_DISABLE;
                pvPut(mirror_sel, SYNC);

                // configure velocity
                velo_sp = gain_mode_velo_sp;
                pvPut(velo_sp, SYNC);
                // configure acceleration
                acc_sp = gain_mode_acc_sp;
                pvPut(acc_sp, SYNC);
                // configure deceleration equal acceleration
                decel_sp = gain_mode_acc_sp;
                pvPut(decel_sp, SYNC);

                // configure relative position
                rel_pos_sp = var_pos_diff;
                pvPut(rel_pos_sp, SYNC);

                // send soft trigger to start motion
                soft_trig_cmd = 1;
                pvPut(soft_trig_cmd, SYNC);
            }


        }

        when (delay(1.0) && motion_state_mon == MOTION_STATE_DONE) {
        } state waiting
    }

    state start_escan {

        entry {
        }

        when (delay(1.0) && motion_state_mon == MOTION_STATE_DONE) {
        } state waiting
    }

    state start_parking {

        entry {

            // local variables
            double var_target_pol, var_target_gain, var_pol_diff, var_gain_diff;

            // calculate polarization position diff
            var_pol_diff = PARKING_POL_SHIFT - pol_shift_mon;

            // calculate gain position diff
            var_gain_diff = PARKING_GAIN_SHIFT - gain_shift_mon;

            // configure trigger to software
            trig_type_sel = TRIG_TYPE_SOFT;
            pvPut(trig_type_sel, SYNC);

            // make sure inter module coupling is right
            inter_mod_coup_sel = INTER_MOD_COUPLING_001;
            pvPut(inter_mod_coup_sel, SYNC);

            // configure motion reference type
            ref_type_sel = REFERENCE_TYPE_INTERNAL;
            pvPut(ref_type_sel, SYNC);

            // make sure mirror is disabled
            mirror_sel = MIRROR_DISABLE;
            pvPut(mirror_sel, SYNC);

            // ADJUST POL
            // select phase coupling
            coup_sel = COUPLING_PHASE;
            pvPut(coup_sel, SYNC);
            // configure velocity
            velo_sp = pol_mode_velo_sp;
            pvPut(velo_sp, SYNC);
            // configure acceleration
            acc_sp = pol_mode_acc_sp;
            pvPut(acc_sp, SYNC);
            // configure deceleration equal acceleration
            decel_sp = pol_mode_acc_sp;
            pvPut(decel_sp, SYNC);
            // configure relative position
            rel_pos_sp = var_pol_diff;
            pvPut(rel_pos_sp, SYNC);
            // send soft trigger to start motion
            soft_trig_cmd = 1;
            pvPut(soft_trig_cmd, SYNC);

            // ADJUST GAIN
            // select gain coupling (GH)
            coup_sel = COUPLING_GH;
            pvPut(coup_sel, SYNC);
            // configure velocity
            velo_sp = gain_mode_velo_sp;
            pvPut(velo_sp, SYNC);
            // configure acceleration
            acc_sp = gain_mode_acc_sp;
            pvPut(acc_sp, SYNC);
            // configure deceleration equal acceleration
            decel_sp = gain_mode_acc_sp;
            pvPut(decel_sp, SYNC);
            // configure relative position
            rel_pos_sp = var_gain_diff;
            pvPut(rel_pos_sp, SYNC);
            // send soft trigger to start motion
            soft_trig_cmd = 1;
            pvPut(soft_trig_cmd, SYNC);
        }

        when (delay(1.0) && motion_state_mon == MOTION_STATE_DONE) {
        } state waiting
    }

}

ss gain_sp_update {

    state init {

        /* set shift_sp event flag so
           that other set points are made
           consistent with it. */

        efSet(shift_sp_flg);

        when () {
        } state check_update
    }

    state check_update {

        when (efTestAndClear(shift_sp_flg)) {

            /* Update equivalent set points
               to keep them consistent.

               Take polarization in consideration
               when doing conversions. */

            mm2k(pol_type_sel, shift_sp, &k_sp);
            pvPut(k_sp, SYNC);
            k2energy(pol_type_sel, k_sp, &energy_sp);
            pvPut(energy_sp, SYNC);

            // clear flags for PVs set here
            efClear(k_sp_flg);
            efClear(energy_sp_flg);

        } state check_update

        when (efTestAndClear(k_sp_flg)) {

            /* Update equivalent set points
               to keep them consistent.

               Take polarization in consideration
               when doing conversions. */

            k2mm(pol_type_sel, k_sp, &shift_sp);
            pvPut(shift_sp, SYNC);
            k2energy(pol_type_sel, k_sp, &energy_sp);
            pvPut(energy_sp, SYNC);

            // clear flags for PVs set here
            efClear(shift_sp_flg);
            efClear(energy_sp_flg);

        } state check_update

        when (efTestAndClear(energy_sp_flg)) {

            /* Update equivalent set points
               to keep them consistent.

               Take polarization in consideration
               when doing conversions. */

            energy2k(pol_type_sel, energy_sp, &k_sp);
            pvPut(k_sp, SYNC);
            k2mm(pol_type_sel, k_sp, &shift_sp);
            pvPut(shift_sp, SYNC);

            // clear flags for PVs set here
            efClear(k_sp_flg);
            efClear(shift_sp_flg);

        } state check_update
    }

}
